<!DOCTYPE html>
<html lang="es">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Consulta | Paris & Bea</title>
  <link rel="stylesheet" href="css/style.css" />
  <link href="https://fonts.googleapis.com/css2?family=Material+Icons+Outlined" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>

  <style>
    /* ‚Äî‚Äî layout fijo ‚Äî‚Äî */
    html,
    body {
      height: 100%;
      margin: 0
    }

    body {
      background: #efefef;
      font-family: "Raleway", sans-serif;
      display: flex;
      flex-direction: column;
      overflow: hidden
    }

    /* ‚Äî‚Äî cabecera ‚Äî‚Äî */
    header {
      flex: 0 0 auto;
      width: 100%;
      max-width: 620px;
      margin: auto;
      padding: 18px 20px;
      box-sizing: border-box;
      display: flex;
      align-items: center;
      gap: 16px;
      border-bottom: 3px solid #aed3c1;
      background: #efefef;
      margin-bottom: 5px
    }

    header img {
      width: 28px
    }

    header .info {
      flex: 1
    }

    header .info h1 {
      font-size: 20px;
      margin: 0
    }

    header .info h2 {
      font-size: 17px;
      font-weight: 500;
      margin: 2px 0 0;
      color: #444
    }

    /* ‚Äî‚Äî panel datos ‚Äî‚Äî */
    #messages {
      flex: 1 1 auto;
      width: 100%;
      max-width: 620px;
      margin: auto;
      padding: 18px 22px;
      box-sizing: border-box;
      background: #fff;
      border-radius: 14px;
      box-shadow: 0 3px 8px rgba(0, 0, 0, .08);
      overflow-y: auto;
      font-size: 15px;
      line-height: 1.4
    }

    .section-title {
      margin: 18px 0 10px;
      font-weight: 1000;
      font-size: 18px;
      border-bottom: 1px solid #aed3c1;
      display: flex;
      align-items: center;
      gap: 6px
    }

    .section-title .material-icons-outlined {
      font-size: 20px;
      color: #4d4d4d
    }

    #messages dl {
      margin: 0
    }

    /* log */
    #log {
      margin-top: 14px
    }

    .feedback {
      padding: 8px 10px;
      border-radius: 8px;
      margin-bottom: 6px;
      font-size: 14px
    }

    /* mensajes del profesional y del asistente ‚Äì modo chat */
    .msg-user {
      background: #e1efff;
      color: #13417b;
      border-left: 6px solid #3b7bff
    }

    .msg-assist {
      background: #d5f6e3;
      color: #276040;
      border-left: 6px solid #28a56a
    }

    .success {
      background: #d5f6e3;
      color: #276040
    }

    .error {
      background: #ffd6d6;
      color: #a12525
    }

    .loader {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
      color: #555
    }

    .loader::before {
      content: '';
      width: 20px;
      height: 20px;
      border: 3px solid #aed3c1;
      border-top-color: transparent;
      border-radius: 50%;
      animation: spin 1s linear infinite
    }

    @keyframes spin {
      to {
        transform: rotate(1turn)
      }
    }

    /* ‚Äî‚Äî selector de bloque ‚Äî‚Äî */
    .block-selector {
      flex: 0 0 auto;
      width: 100%;
      max-width: 620px;
      margin: auto;
      padding: 8px 4px;
      display: flex;
      justify-content: space-around;
      gap: 6px;
      background: #efefef
    }

    .chip {
      flex: 1;
      padding: 8px 4px;
      border: 2px solid #aed3c1;
      border-radius: 12px;
      background: #fff;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      transition: .15s
    }

    .chip.active {
      background: #aed3c1;
      color: #fff
    }

    /* ‚Äî‚Äî botonera ‚Äî‚Äî */
    .bottom-bar {
      flex: 0 0 auto;
      width: 100%;
      max-width: 620px;
      margin: auto;
      padding: 14px 0;
      display: flex;
      justify-content: space-around;
      gap: 16px;
      background: #efefef
    }

    .btn-round {
      width: 60px;
      height: 60px;
      border: none;
      border-radius: 50%;
      background: #aed3c1;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: 0 4px 10px rgba(0, 0, 0, .15);
      transition: background .2s, transform .15s;
      width: 60px;
      height: 60px;
      border: 2px solid transparent;
      border-radius: 50%;
      background: #aed3c1;
    }

    .btn-round.recording {
      background: #e04141;
      animation: pulse 1s infinite;
    }

    .btn-round:active {
      transform: scale(.94)
    }

    .btn-round.recording {
      background: #e04141
    }

    .btn-round .material-icons-outlined {
      font-size: 24px;
      color: #fff;
      line-height: 1
    }

    .btn-small {
      width: 45px;
      height: 45px
    }

    .btn-small .material-icons-outlined {
      font-size: 20px
    }

    /* ‚Äî‚Äî modal gu√≠a ‚Äî‚Äî */
    #modalGuide {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, .55);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 999;
      pointer-events: none
        /* <- deja pasar los clics */
    }

    #modalGuide .panel {
      width: 90%;
      max-width: 300px;
      background: #fff;
      border-radius: 14px;
      padding: 20px;
      box-shadow: 0 8px 20px rgba(0, 0, 0, .25);
      animation: pop .25s ease-out;
      pointer-events: auto
        /* panel s√≠ recibe scroll */
    }

    #modalGuide h3 {
      margin: 0 0 12px;
      font-size: 24px;
      text-align: center;
      color: #276040
    }

    #modalGuide ul {
      margin: 0;
      padding-left: 26px;
      font-size: 20px;
      line-height: 1.5
    }

    @keyframes pop {
      0% {
        transform: scale(.8);
        opacity: 0
      }

      100% {
        transform: scale(1);
        opacity: 1
      }
    }

    .chip.hidden {
      display: none
    }

    /* ---------- bot√≥n ‚ÄúHablar‚Äù en modo grabaci√≥n ---------- */
    .btn-round.talking {
      background: #e04141;
      /* rojo */
      animation: pulse 1s infinite;
    }

    #btnStopTTS {
      background: #a12525;
    }

    @keyframes pulse {
      0% {
        box-shadow: 0 0 0 0 rgba(224, 65, 65, .6)
      }

      70% {
        box-shadow: 0 0 0 12px rgba(224, 65, 65, 0)
      }

      100% {
        box-shadow: 0 0 0 0 rgba(224, 65, 65, 0)
      }
    }

    /* evita que enlaces largos se salgan del contenedor */
    .feedback a {
      word-break: break-all;
      /* rompe la palabra donde haga falta */
      overflow-wrap: anywhere;
      /* respaldo para otros navegadores   */
    }

    /* miniaturas que muestra el asistente */
    .feedback img.thumb {
      max-width: 140px;
      /* ancho m√°x. de la miniatura */
      height: auto;
      border-radius: 6px;
      cursor: pointer;
      display: block;
      /* cada imagen en su propia l√≠nea */
      margin: 6px 0;
    }

    .btnSaveAttach {
      border: none;
      background: none;
      cursor: pointer;
      font-size: 17px;
      margin-left: 6px;
      line-height: 1;
      color: #276040;
    }

    .btnSaveAttach:hover {
      transform: scale(1.15);
    }

    .thumb-wrap {
      position: relative;
      display: inline-block;
    }

    .pin,
    .lens {
      cursor: pointer;
      font-size: 18px;
      margin-left: 6px;
      user-select: none;
      color: #276040;
    }

    .pin:hover,
    .lens:hover {
      transform: scale(1.15);
    }

    .probe {
      cursor: pointer;
      margin-left: 4px
    }

    .probe:hover {
      filter: brightness(1.2)
    }

    .btnSaveAttach {
      background: none;
      border: none;
      cursor: pointer;
      margin-left: 4px
    }

    .thumb-wrap,
    .file-wrap {
      display: inline-flex;
      align-items: center;
      gap: 4px
    }

    /* ‚Äî‚Äî wrapper flex que aloja los dos paneles ‚Äî‚Äî */
    #panels {
      flex: 1 1 auto;
      width: 100%;
      max-width: 1900px;
      margin: auto;
      display: flex;
      flex-direction: column;
      gap: 8px;
      /* peque√±a separaci√≥n entre paneles */
    }

    /* ‚Äî‚Äî panel con datos del pac ‚Äî‚Äî */
    .info-panel {
      /* heredamos el estilo que antes ten√≠a #messages */
      background: #fff;
      border-radius: 14px;
      box-shadow: 0 3px 8px rgba(0, 0, 0, .08);
      padding: 18px 22px;
      box-sizing: border-box;
      overflow-y: auto;
      font-size: 15px;
      line-height: 1.4;
      /* ocupa solo lo necesario */
      flex: 0 0 auto;
    }

    /* ‚Äî‚Äî panel de chat/log ‚Äî‚Äî */
    .chat-panel {
      /* mismo aspecto para mantener coherencia */
      background: #fff;
      border-radius: 14px;
      box-shadow: 0 3px 8px rgba(0, 0, 0, .08);
      padding: 18px 22px;
      box-sizing: border-box;
      overflow-y: auto;
      font-size: 15px;
      line-height: 1.4;
      /* se expande y ocupa el resto de la altura disponible */
      flex: 1 1 auto;
    }

    /* ‚Äî‚Äî ALTURA Y SCROLL ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî */
    /* el panel con datos ocupar√° como m√°ximo el 45 % de la ventana;
   si su contenido crece, aparecer√° scroll interno            */
    .info-panel {
      max-height: 45vh;
      /* vh = % de la altura de la ventana */
      overflow-y: auto;
    }

    /* el panel de chat crece para usar el resto del espacio        */
    .chat-panel {
      flex: 1 1 auto;
      overflow-y: auto;
    }

    /* ‚Äî‚Äî RESTAURAMOS LOS ESTILOS DE DT / DD ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî */
    .info-panel dl {
      margin: 0;
    }

    .info-panel dt {
      font-weight: 700;
      float: left;
      width: 120px;
      clear: left;
      white-space: nowrap;
    }

    .info-panel dd {
      margin: 0 0 6px 120px;
    }

    /* ‚Äî‚Äî T√≠tulos de secci√≥n dentro del nuevo panel ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî */
    .info-panel .section-title {
      margin: 18px 0 10px;
      font-weight: 1000;
      font-size: 18px;
      border-bottom: 1px solid #aed3c1;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .info-panel .section-title .material-icons-outlined {
      font-size: 20px;
      color: #4d4d4d;
    }

    @media (min-width:900px) {

      /* El wrapper pasa de columna ‚Üí fila */
      #panels {
        flex-direction: row;
      }

      /* Ambos paneles comparten el ancho disponible ---------------- */
      .info-panel,
      .chat-panel {
        flex: 1 1 50%;
        /* mitad cada uno                                      */
        max-width: 50%;
        /* evita que crezcan m√°s del 50 %                      */
        height: auto;
        /* dejamos que hereden la altura del contenedor flex   */
      }

      /* El panel de datos ya no necesita limitaci√≥n de altura
     (se repartir√° verticalmente junto al chat) */
      .info-panel {
        max-height: none;
      }

      /* Opcional: a√±ade un poco m√°s de separaci√≥n entre ellos       */
      #panels {
        gap: 16px;
        /* en vertical seguir√° usando el gap original (8 px)   */
      }
    }

    /* ‚Äî‚Äî  GARANTIZA QUE #panels PUEDE ENCOGERSE  ‚Äî‚Äî */
    #panels {
      min-height: 0;
      /* clave: deja que se reduzca verticalmente */
    }

    /* ‚Äî‚Äî  LOS DOS SUB-PANELES TAMBI√âN PUEDEN ENCOGERSE  ‚Äî‚Äî */
    .info-panel,
    .chat-panel {
      min-height: 0;
      /* sin esto ‚Äúcrecen‚Äù y empujan al footer   */
      overflow-y: auto;
      /* si se quedan sin espacio ‚Üí scroll interno */
    }

    /* ‚Äî‚Äî  OPCIONAL: en escritorio quita expl√≠citamente height:auto ‚Äî‚Äî‚Äî‚Äî */
    @media (min-width:900px) {

      .info-panel,
      .chat-panel {
        height: auto;
        margin: 3px;
      }
    }

    @media (min-width:900px) {

      /* 1) Reservamos hueco al fondo para header + bottom-bar */
      body {
        padding-bottom: calc(60px
            /* bottom-bar */
            + 16px
            /* gap */
            + 60px
            /* header */
          );
      }

      /* 2) Fijamos la bottom-bar */
      .bottom-bar {
        position: fixed;
        bottom: 0;
        left: 50%;
        transform: translateX(-50%);
        width: 100%;
        max-width: 600px;
        z-index: 20;
      }

      /* 3) Fijamos la cabecera justo encima de la bottom-bar */
      header {
        position: fixed;
        bottom: calc(60px + 16px);
        /* altura bottom-bar + gap */
        left: 50%;
        transform: translateX(-50%);
        width: 100%;
        max-width: 1900px;
        z-index: 20;
      }

      /* 4) Ajustes menores al wrapper de paneles */
      #panels {
        margin-top: 0;
        /* pegadito arriba */
        /* el gap horizontal ya lo tienes a 16px */
      }

      /* 1) Fija el selector de bloques encima del header */
      .block-selector {
        position: fixed;
        bottom: calc(50px
            /* altura de la bottom-bar */
            + 16px
            /* gap */
            + 60px
            /* altura de tu header fija */
          );
        left: 50%;
        transform: translateX(-50%);
        width: 100%;
        max-width: 600px;
        z-index: 20;
        /* conserva su fondo para que no transparente */
        background: transparent;
      }

      /* 2) Reserva hueco en el body para:
     - bottom-bar (60px)
     - gap (16px)
     - header (60px)
     - block-selector (aprox. 40px) */
      body {
        padding-bottom: calc(60px
            /* bottom-bar */
            + 16px
            /* gap */
            + 60px
            /* header */
            + 40px
            /* block-selector */
          );
      }
    }
  </style>
</head>

<body>

  <!-- CABECERA -->
  <header>
    <img src="images/recursos/otro-logo.png" alt="Logo" />
    <div class="info">
      <h1 id="profName">Profesional</h1>
      <h2 id="pacName">Paciente</h2>
    </div>
  </header>

  <!-- PANELES -->
  <div id="panels">
    <!-- Datos del paciente -->
    <div id="infoPanel" class="panel info-panel">
      <div id="mainData">Cargando‚Ä¶</div>
    </div>

    <!-- Chat, asistente y logs -->
    <div id="chatPanel" class="panel chat-panel">
      <div id="log"></div>
    </div>
  </div>

  <!-- Modal gu√≠a -->
  <div id="modalGuide">
    <div class="panel">
      <h3 id="modalTitle"></h3>
      <ul id="modalList"></ul>
      <button id="btnGuideCancel" style="margin-top:18px;padding:8px 22px;background:#a12525;
                 border:none;border-radius:10px;color:#fff;font-weight:700;
                 cursor:pointer">
        Cancelar
      </button>
    </div>
  </div>

  <!-- Modal timeout 25 min -->
  <div id="modalTimeout" style="display:none;position:fixed;inset:0;
     background:rgba(0,0,0,.55);z-index:1000;align-items:center;justify-content:center">
    <div class="panel" style="background:#fff;padding:26px 30px;border-radius:14px;
       max-width:320px;text-align:center;font-size:16px;pointer-events:auto">
      <p>‚è±Ô∏è La grabaci√≥n lleva m√°s de 25&nbsp;min.<br>¬øQu√© quieres hacer?</p>
      <button id="btnCancel" style="margin:10px 8px 0;padding:8px 18px;background:#a12525;
            border:none;border-radius:10px;color:#fff;cursor:pointer">Cancelar</button>
      <button id="btnSend" style="margin:10px 8px 0;padding:8px 18px;background:#276040;
            border:none;border-radius:10px;color:#fff;cursor:pointer">Enviar</button>
    </div>
  </div>

  <!-- SELECTOR DE BLOQUE -->
  <div class="block-selector">
    <button class="chip active" data-block="historial" id="chipHist">Historial</button>
    <button class="chip" data-block="evaluacion" id="chipEval">Evaluaci√≥n</button>
    <button class="chip" data-block="tratamiento" id="chipTrat">Tratamiento</button>
    <button class="chip" data-block="sesion" id="chipSes">Sesi√≥n</button>
  </div>

  <!-- BOTONES -->
  <div class="bottom-bar">
    <button id="btnRecord" class="btn-round" title="Grabar bloque">
      <span class="material-icons-outlined">mic</span></button>
    <button id="btnHome" class="btn-round btn-small" title="Cambiar de paciente">
      <span class="material-icons-outlined">home</span></button>
    <button id="btnKeyboard" class="btn-round btn-small" title="Escribir al asistente">
      <span class="material-icons-outlined">keyboard</span>
    </button>
    <button id="btnUpload" class="btn-round btn-small" title="Adjuntar archivo">
      <span class="material-icons-outlined">add</span>
    </button>
    <input id="filePicker" type="file" accept=".pdf,.doc,.docx,.png,.jpg,.jpeg,.webp,.gif,.heic" multiple
      style="display:none">
    <button id="btnStopTTS" class="btn-round btn-small" title="Parar voz" style="display:none">
      <span class="material-icons-outlined">stop</span>
    </button>
    <button id="btnTalk" class="btn-round" title="Hablar con el asistente">
      <img src="images/recursos/voice_icon.png" style="max-width:30px" alt="Logo" /></button>
  </div>
  <div id="textPanel" style="display:none;padding:8px;max-width:620px;margin:auto;text-align:center">
    <!-- de input ‚Üí textarea -->
    <textarea id="txtMessage" placeholder="Escribe‚Ä¶" style="width:100%;min-height:48px;max-height:260px;
                   padding:10px;border:2px solid #aed3c1;border-radius:10px;
                   font-size:15px;resize:vertical;overflow:auto"></textarea>

    <button id="btnSaveChat" style="margin:15px;padding:7px 22px;border:none;border-radius:10px;
                 background:#aed3c1;color:#fff;font-weight:600;cursor:pointer">
      Guardar conversaci√≥n
    </button>
  </div>

  <script>
    /* ------------------------------------------------ utilidades b√°sicas ------------------------------------------------ */
    const $id = id => document.getElementById(id);
    /* ---------- manejo de chat persistente ---------- */
    let activeChatId = null;          // se rellenar√° al primer guardado
    let chatChanged = false;         // true cuando hay algo nuevo sin salvar
    window.sessionImages = [];

    /* ================= CLICK GLOBAL (üìå / üîç) ================= */
    document.addEventListener('click', async e => {

      /* ---------- 1 ¬∑ GUARDAR adjunto temporal (üìå) ---------- */
      if (e.target.classList.contains('btnSaveAttach')) {
        /* ‚Ä¶handler de guardado‚Ä¶ */
        return;
      }

      /* ---------- 2 ¬∑ ANALIZAR adjunto permanente (üîç) ---------- */
      const probe = e.target.closest('.probe');
      if (!probe) return;

      const url = probe.dataset.url;
      if (!url) return;

      const isImg = /\.(jpe?g|png|webp|gif|bmp|svg|heic)$/i.test(url);
      const userQ = inpMsg.value.trim() ||
        (isImg ? 'Describe brevemente esta imagen.'
          : 'Hazme un breve resumen de este documento.');

      /* limpiar textarea y volcar pregunta */
      inpMsg.value = '';
      autoGrow(inpMsg);
      log.insertAdjacentHTML(
        'beforeend',
        `<div class="feedback msg-user">${linkify(userQ)}</div>`
      );
      chatChanged = true;
      log.scrollTop = log.scrollHeight;

      /* ============ 2.a ¬∑ IMAGEN ============ */
      if (isImg) {
        if (!window.sessionImages.includes(url)) {
          window.sessionImages.push(url);
          if (window.sessionImages.length > 5) window.sessionImages.shift();
        }
        await sendToAssistant({ message: userQ, images: [...window.sessionImages] });
        return;
      }

      // 2.b ¬∑ PDF / WORD / OTRO DOC
      try {
        ensureLoader();

        // 1) extrae la ruta relativa (sin protocolo ni host)
        const relPath = new URL(probe.dataset.url).pathname.replace(/^\/+/, '');

        // 2) llama al endpoint de ingesta
        const rr = await fetch('/api/assistant/files/ingest', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ filepath: relPath }),
          credentials: 'include'
        });
        const jj = await rr.json();
        if (!jj.ok) throw new Error(jj.error || 'Error preparando doc');

        // ‚Äî‚Äî Inserta un mensaje en el chat con el resultado de la funci√≥n ‚Äî‚Äî  
        log.insertAdjacentHTML('beforeend',
          `<div class="feedback info">
		   üìÑ Documento preparado: file_id=${jj.file_id}, vs=${jj.vector_store}
		 </div>`
        );
        chatChanged = true;
        log.scrollTop = log.scrollHeight;

        // 3) ahora s√≠ haz la pregunta al asistente
        await sendToAssistant({ message: userQ });

      } catch (err) {
        safeRemoveLoader();
        log.insertAdjacentHTML('beforeend',
          `<div class="feedback error">${linkify(err.message)}</div>`
        );
        chatChanged = true;
        log.scrollTop = log.scrollHeight;
      }
    });

    document.addEventListener('click', async e => {
      const lens = e.target.closest('.lens');
      if (!lens) return;

      const url = lens.dataset.url;
      const msg = $id('txtMessage').value.trim();
      if (!msg) {
        alert('Escribe tu consulta antes de pulsar el icono üî¨');
        return;
      }

      $id('txtMessage').value = '';
      $id('textPanel').style.display = 'none';

      log.insertAdjacentHTML(
        'beforeend',
        `<div class="feedback msg-user">${linkify(msg)}</div>`
      );
      chatChanged = true;
      log.scrollTop = log.scrollHeight;

      const ext = url.split('.').pop().toLowerCase();
      const isImg = /\.(jpe?g|png|webp|gif|bmp)$/i.test(url);

      const body = {
        message: msg,
        ...(isImg ? { images: [url] } : {})
      };

      ensureLoader();
      try {
        const r = await fetch('/api/assistant/chat', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body),
          credentials: 'include'
        });
        const j = await r.json();
        await handleAssistantResponse(j);
      } catch (err) {
        safeRemoveLoader();
        log.insertAdjacentHTML(
          'beforeend',
          `<div class="feedback error">${err.message}</div>`
        );
        chatChanged = true;
        log.scrollTop = log.scrollHeight;
      }
    });

    /* ---------- construye el body para /assistant/chat ---------- */
    function buildAssistantBody(msg) {
      const body = { message: msg };
      if (window.sessionImages.length) {
        body.images = [...window.sessionImages];      // copia defensiva
      }
      return body;
    }

    const serializeChat = () => log.innerHTML;  // volcamos tal cual el HTML
    const row = (l, v) => v ? `<dt>${l}</dt><dd>${v}</dd>` : '';
    const title = (i, t) => `<div class="section-title"><span class="material-icons-outlined">${i}</span>${t}</div>`;
    /* ---------- formateador de fechas ---------- */
    const fDate = d => {
      /* 1) vac√≠o, null o undefined ‚Üí nada */
      if (!d) return '';

      /* 2) si viene como string ‚Äú0000-00-00‚Äù  ‚Üí nada */
      if (typeof d === 'string' && /^0{4}-0{2}-0{2}$/.test(d.trim())) return '';

      /* 3) pasamos a objeto Date */
      const dateObj = new Date(d);

      /* 4) inv√°lido o siglo XIX (efecto 30-11-1899) ‚Üí nada */
      if (isNaN(dateObj) || dateObj.getFullYear() < 1900) return '';

      /* 5) formato dd/mm/aaaa üá™üá∏ */
      return dateObj.toLocaleDateString('es-ES', {
        day: '2-digit',
        month: '2-digit',
        year: 'numeric'
      });
    };

    const fTime = t => t ? t.slice(0, 5) : '';

    let currentBlock = 'historial';

    /* ---------- linkify con üîç y üìå ---------- */
    const linkify = txt =>
      txt.replace(/(https?:\/\/[^\s]+)/g, url => {
        const isImg = /\.(jpe?g|png|webp|gif|bmp|svg|heic)$/i.test(url);
        const isStored = /\/attachments_consulta\//i.test(url);  // ya guardado
        const showPin = !isStored && !isImg;                   // pin solo para tmp-PDF
        const iconProbe = `<span class="probe" data-url="${url}" title="Analizar">üîç</span>`;
        const iconPin = showPin ? `<button class="btnSaveAttach" data-tmp="${url.split('/').pop()}" title="Guardar">üìå</button>` : '';

        if (isImg) {
          return `
        <div class="thumb-wrap">
          <a href="${url}" target="_blank" rel="noopener"><img src="${url}" class="thumb" /></a>
          ${iconProbe}${iconPin}
        </div>`;
        }
        // PDF / Word u otros
        return `<div class="file-wrap">
              <a href="${url}" target="_blank" rel="noopener noreferrer">${url}</a>
              ${iconProbe}${iconPin}
            </div>`;
      });

    /* ‚îÄ‚îÄ‚îÄ‚îÄ Maneja la respuesta del backend ‚îÄ‚îÄ‚îÄ‚îÄ */
    async function handleAssistantResponse(j, silent = false) {
      if (!j.ok) return;                        // errores ya se tratan arriba

      /* caso 1: respuesta con texto visible */
      if (j.reply && j.reply.trim()) {
        if (!silent) {                           // solo mostramos si no es ‚Äúsilencioso‚Äù
          log.insertAdjacentHTML(
            'beforeend',
            `<div class="feedback success">${linkify(j.reply)}</div>`
          );
          log.scrollTop = log.scrollHeight;
        }
        if (j.audioUrl) playTTS(j.audioUrl);    // voz si procede
        return;                                // ¬°nada m√°s que hacer!
      }

      /* caso 2: mensaje vac√≠o ‚Üí pedir que complete */
      console.log('[auto] Respuesta vac√≠a; solicitando continuaci√≥n‚Ä¶');
      const next = await sendHidden('Completa todo lo que te he pedido');
      await handleAssistantResponse(next, true);   // recursivo / silencioso
    }

    /* ------- env√≠a mensaje silencioso ------- */
    async function sendHidden(msg) {
      try {
        const r = await fetch('/api/assistant/chat', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(buildAssistantBody(msg))
        });
        return await r.json();
      } catch (e) {
        console.error('Hidden call error', e);
        return { ok: false, reply: '' };
      }
    }

    /* ------- spinner helpers ------- */
    const ensureLoader = () => $id('spin') || addLoader();
    const safeRemoveLoader = () => removeLoader();

    async function sendToAssistant(body) {
      ensureLoader();
      try {
        const r = await fetch('/api/assistant/chat', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body),
          credentials: 'include'
        });
        const j = await r.json();
        await handleAssistantResponse(j);
      } catch (err) {
        safeRemoveLoader();
        log.insertAdjacentHTML(
          'beforeend', `<div class="feedback error">${linkify(err.message)}</div>`
        );
        chatChanged = true; log.scrollTop = log.scrollHeight;
      }
    }

    /* ------- gestor recursivo de respuestas ------- */
    async function handleAssistantResponse(j, silent = false, depth = 0) {
      if (depth > 3) {            // evita bucle infinito
        safeRemoveLoader();
        return;
      }
      if (!j || !j.ok) {        // error ya tratado por caller
        safeRemoveLoader();
        return;
      }

      /* --------- caso 1: hay texto --------- */
      if (j.reply && j.reply.trim()) {
        safeRemoveLoader();
        if (!silent) {
          log.insertAdjacentHTML(
            'beforeend',
            `<div class="feedback msg-assist">${linkify(j.reply)}</div>`
          );
          chatChanged = true;
          log.scrollTop = log.scrollHeight;
        }
        if (j.audioUrl) playTTS(j.audioUrl);
        return;
      }

      /* --------- caso 2: solo audio --------- */
      if (j.audioUrl) {
        safeRemoveLoader();
        playTTS(j.audioUrl);
        return;
      }

      /* --------- caso 3: respuesta vac√≠a ‚Üí re-preguntar --------- */
      ensureLoader();                     // mantenemos spinner
      const next = await sendHidden('Completa todo lo que te he pedido');
      await handleAssistantResponse(next, true, depth + 1);
    }

    /* ------------------------------------------------ gu√≠as por bloque --------------------------------------------------- */
    const guide = {
      historial: ['Motivo consulta', 'Fecha inicio problema', 'Antecedentes personales', 'Antecedentes familiares',
        'Tratamientos previos', 'Medicaci√≥n actual', 'Alergias', 'H√°bitos de vida', 'Profesi√≥n'],
      evaluacion: ['Localizaci√≥n dolor', 'Intensidad dolor', 'Tipo dolor', '¬øIrradia? S√≠/No', 'Descripci√≥n', 'Inspecci√≥n visual',
        'Palpaci√≥n', 'Movilidad articular', 'Pruebas funcionales', 'Valoraci√≥n neurol√≥gica', 'Evaluaci√≥n funcional',
        'Diagn√≥stico', 'Objetivos terap√©uticos'],
      tratamiento: ['Fecha inicio', 'Duraci√≥n / fecha fin', 'T√©cnicas aplicadas', 'Frecuencia sesiones', 'Duraci√≥n sesiones',
        'Recomendaciones', 'Suplementaci√≥n', 'Fecha inicio suplementaci√≥n', 'C√°psulas por bote', 'D√≠as antes para alerta'],
      sesion: ['T√©cnicas utilizadas', 'Evoluci√≥n paciente', '¬øModif. tratamiento?', 'Observaciones']
    };

    function showGuide(block) {
      $id('modalTitle').textContent = block.toUpperCase();
      $id('modalList').innerHTML = guide[block].map(li => `<li>${li}</li>`).join('');
      $id('modalGuide').style.display = 'flex';
    }
    function hideGuide() { $id('modalGuide').style.display = 'none'; }

    /* ------------------------------------------------ control de tiempo de grabaci√≥n ------------------------------------ */
    const maxBlockMs = 25 * 60 * 1000;   /* 25 minutos en milisegundos           */
    let blockTimer = null;             /* id devuelto por setTimeout           */
    let exceeded = false;            /* true si se super√≥ el tiempo          */
    let manualCancel = false;            /* true si el usuario pulsa ‚ÄúCancelar‚Äù  */

    /* ---- helpers modal timeout (Cancelar / Enviar) ---- */
    function showTimeoutModal() { $id('modalTimeout').style.display = 'flex'; }
    function hideTimeoutModal() { $id('modalTimeout').style.display = 'none'; }

    /* cerrar tocando fuera de la tarjeta */
    $id('modalTimeout').addEventListener('click', e => {
      if (e.target.id === 'modalTimeout') hideTimeoutModal();
    });

    /* botones dentro del modal (tope 25 min) */
    $id('btnCancel').onclick = () => {
      hideTimeoutModal();
      log.insertAdjacentHTML('beforeend',
        '<div class="feedback error">‚ùå Grabaci√≥n cancelada (exced√≠a 25&nbsp;min)</div>');
      chatChanged = true;
      log.scrollTop = log.scrollHeight;
    };
    $id('btnSend').onclick = () => {
      hideTimeoutModal();
      exceeded = false;          /* permite continuar */
      sendBlock();               /* relanza env√≠o      */
    };

    /* ------------------------------------------------ bot√≥n Cancelar en modal-gu√≠a -------------------------------------- */
    function cancelGuideRecording() {
      if (rec) {
        manualCancel = true;                /* marcar cancelaci√≥n manual */
        clearTimeout(blockTimer);
        recorder.stop();                    /* disparar√° sendBlock()     */
        rec = false;
        btnRec.classList.remove('recording');
      }
      hideGuide();
    }
    $id('btnGuideCancel').onclick = cancelGuideRecording;

    /* ------------------------------------------------ carga inicial de la ficha ----------------------------------------- */
    async function loadSession() {
      const main = $id('mainData');
      try {
        const data = await (await fetch('/api/session/info')).json();
        if (!data.user || !data.patient) { main.textContent = '‚ùå Sesi√≥n no v√°lida'; return; }
        $id('profName').textContent = data.user.nombre;
        $id('pacName').textContent = data.patient.nombre + ' ' + data.patient.apellidos;

        /* ---- ocultar chip Historial si ya existe ---- */
        const chipHist = $id('chipHist');
        if (data.historial) {
          chipHist.classList.add('hidden');
          if (currentBlock === 'historial') {                       /* cambiamos chip activo */
            currentBlock = 'evaluacion';
            document.querySelectorAll('.chip').forEach(c => c.classList.remove('active'));
            $id('chipEval').classList.add('active');
          }
        } else {
          chipHist.classList.remove('hidden');
        }

        /* ---- construir HTML de detalles ---- */
        let html = '', p = data.patient, h = data.historial;
        html += title('account_circle', 'Historial cl√≠nico');
        html += `<dl>${row('Alta', fDate(p.fecha_registro))}${row('Nacimiento', fDate(p.fecha_nacimiento))}
             ${h ? `${row('Motivo', h.motivo_consulta)}${row('Inicio', fDate(h.fecha_inicio_problema))}
                    ${row('Anteced.', h.antecedentes_personales)}${row('Ant. fam.', h.antecedentes_familiares)}${row('Trat. prev.', h.tratamientos_previos)}
                    ${row('Medicaci√≥n', h.medicacion_actual)}${row('Alergias', h.alergias)}
                    ${row('H√°bitos', h.habitos_vida)}${row('Profesi√≥n', h.profesion)}` : ''}</dl>`;

        if (data.evaluacion) {
          const e = data.evaluacion;
          html += title('fact_check', '√öltima evaluaci√≥n');
          html += `<dl>${row('Profesional', e.prof_nombre)}${row('Fecha', fDate(e.fecha_evaluacion))}
               ${row('Localiz. dolor', e.dolor_localizacion)}${row('Intensidad', e.dolor_intensidad)}
               ${row('Tipo dolor', e.dolor_tipo)}${row('Irradia', e.dolor_irradia ? 'S√≠' : 'No')}
               ${row('Descripci√≥n', e.dolor_descripcion)}${row('Insp. visual', e.inspeccion_visual)}
               ${row('Palpaci√≥n', e.palpacion)}${row('Mov. artic.', e.movilidad_articular)}
               ${row('Pruebas fun.', e.pruebas_funcionales)}${row('Val. neuro.', e.valoracion_neurologica)}
               ${row('Val. post.', e.valoracion_postural)}${row('Val. func.', e.evaluacion_funcional)}
               ${row('Diagn√≥stico', e.diagnostico)}${row('Obj. terap.', e.objetivos_terapeuticos)}</dl>`;
        }

        if (data.tratamiento) {
          const t = data.tratamiento;
          html += title('local_hospital', '√öltimo tratamiento');
          html += `<dl>${row('Profesional', t.prof_nombre)}${row('Inicio', fDate(t.fecha_inicio))}
               ${row('Fin', fDate(t.fecha_fin))}${row('Tec. aplic.', t.tecnicas_aplicadas)}
               ${row('Frec. sesi√≥n', t.frecuencia_sesiones)}${row('Dur. sesi√≥n', t.duracion_sesion)}
               ${row('Recomend.', t.recomendaciones)}${row('Estado', t.estado)}
               ${row('Suplemento', t.suplemento_prescrito ? 'S√≠' : 'No')}
               ${row('Caps. x bote', t.capsulas_por_bote)}${row('Dosis diaria', t.dosis_diaria)}
               ${row('Ini. suplem.', fDate(t.fecha_inicio_suplementacion))}
               ${row('Alert. suplem.', t.dias_alerta)}</dl>`;
        }

        if (data.sesion) {
          const s = data.sesion;
          html += title('event', '√öltima sesi√≥n');
          html += `<dl>${row('Profesional', s.prof_nombre)}
               ${row('Fecha', fDate(s.fecha_sesion) + ' ' + fTime(s.hora_sesion))}
               ${row('T√©cnicas', s.tecnicas_utilizadas)}${row('Evoluci√≥n', s.evolucion)}
               ${row('Mod. trat.', s.modificaciones_tratamiento)}${row('Observac.', s.observaciones)}
               ${row('Bono', s.id_bono)}</dl>`;
        }

        main.innerHTML = html;
      } catch (e) { console.error(e); main.textContent = 'Error cargando datos'; }
    }
    loadSession();

    /* ------------------------------------------------ selector de bloque ------------------------------------------------ */
    document.querySelectorAll('.chip').forEach(btn => {
      btn.onclick = () => {
        if (btn.classList.contains('hidden')) return;      /* ignorar chip oculto */
        document.querySelector('.chip.active')?.classList.remove('active');
        btn.classList.add('active');
        currentBlock = btn.dataset.block;
      };
    });

    /* ------------------------------------------------ grabaci√≥n --------------------------------------------------------- */
    const btnRec = $id('btnRecord'), log = $id('log');
    let rec = false, recorder, chunks = [];

    btnRec.onclick = async () => {
      if (!rec) {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });

        // 1) elegimos MIME seg√∫n soporte
        let options = {};
        if (MediaRecorder.isTypeSupported('audio/webm;codecs=opus')) {
          options.mimeType = 'audio/webm;codecs=opus';
        } else {
          options.mimeType = 'video/mp4';
        }

        // 2) creamos recorder con timeslice de 1 s
        recorder = new MediaRecorder(stream, options);
        chunks = [];
        recorder.ondataavailable = e => chunks.push(e.data);
        recorder.onstop = sendBlock;
        recorder.start(1000);

        // ‚Ä¶ resto id√©ntico ‚Ä¶
        rec = true;
        manualCancel = false;
        btnRec.classList.add('recording');
        showGuide(currentBlock);

        exceeded = false;
        blockTimer = setTimeout(() => {
          if (rec) { exceeded = true; btnRec.click(); }
        }, maxBlockMs);

      } else {
        // parada normal, igual que antes
        clearTimeout(blockTimer);
        recorder.stop();
        rec = false;
        btnRec.classList.remove('recording');
      }
    };

    /* ------------------------------------------------ feedback / loader -------------------------------------------------- */
    function addLoader() {
      log.insertAdjacentHTML('beforeend', '<div class="loader" id="spin">Procesando‚Ä¶</div>');
      chatChanged = true;
      log.scrollTop = log.scrollHeight;
    }
    const removeLoader = () => { $id('spin')?.remove(); };

    /* -------------------- guardar adjunto permanente -------------------- */
    log.addEventListener('click', async e => {
      if (!e.target.classList.contains('btnSaveAttach')) return;

      const btn = e.target;
      const wrapper = btn.closest('.attach');
      const tmpName = btn.dataset.tmp;
      if (!tmpName) return;

      btn.disabled = true;
      btn.textContent = '‚è≥';

      try {
        const r = await fetch('/api/assistant/files/save', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ tmpName }),
          credentials: 'include'
        });
        const j = await r.json();
        if (!j.ok) throw new Error(j.error || 'Error');

        wrapper.classList.remove('success');
        wrapper.classList.add('info');
        btn.remove();                         // ya no hace falta el pin
        wrapper.insertAdjacentHTML(
          'beforeend',
          `<div style="margin-top:4px">‚úÖ Guardado</div>`
        );
      } catch (err) {
        btn.disabled = false;
        btn.textContent = 'üìå';
        alert('No se pudo guardar: ' + err.message);
      }
    });


    /* ------------------------------------------------ env√≠o del bloque --------------------------------------------------- */
    async function sendBlock() {
      hideGuide();
      clearTimeout(blockTimer);

      /* cancelaci√≥n manual desde el modal-gu√≠a */
      if (manualCancel) {
        manualCancel = false;
        chunks = [];                       /* ignoramos audio */
        log.insertAdjacentHTML('beforeend',
          '<div class="feedback error">‚ùå Grabaci√≥n cancelada</div>');
        chatChanged = true;
        log.scrollTop = log.scrollHeight;
        return;
      }

      /* se excedi√≥ el tiempo: mostrar modal decidir */
      if (exceeded) {
        showTimeoutModal();
        return;
      }

      addLoader();
      // 1) obtenemos MIME y extensi√≥n
      const mime = recorder.mimeType || 'audio/webm';
      const ext = mime.includes('mp4') ? '.mp4' : '.webm';

      // 2) construimos blob+form con la extensi√≥n correcta
      const blob = new Blob(chunks, { type: mime });
      const form = new FormData();
      form.append('audio', blob, 'bloque' + ext);
      form.append('block', currentBlock);

      try {
        const r = await fetch('/api/blocks/upload', { method: 'POST', body: form });
        const j = await r.json(); removeLoader();

        log.insertAdjacentHTML('beforeend',
          `<div class="feedback ${j.ok ? 'success' : 'error'}">${j.ok ? j.message : j.error}</div>`);
        chatChanged = true;
        log.scrollTop = log.scrollHeight;

        if (j.ok) loadSession();
      } catch (e) {
        removeLoader();
        log.insertAdjacentHTML('beforeend', '<div class="feedback error">Error de red</div>');
        chatChanged = true;
        log.scrollTop = log.scrollHeight;
      }
    }

    /* ------------------------------------------------ bot√≥n HABLAR (voz ‚Üî assistant) ---------------------------------- */
    const btnTalk = $id('btnTalk');
    const btnStop = $id('btnStopTTS');     // mismo bot√≥n sirve para ‚Äúparar voz / cancelar‚Äù

    let talking = false;                // ¬øestamos grabando pregunta?
    let recVoice, chunksVoice = [];
    let currentAudio = null;                // reproducci√≥n TTS activa

    /* --- voz espa√±ola ‚Äúfemenina‚Äù si existe --- */
    function getVoiceES() {
      const v = speechSynthesis.getVoices();
      return v.find(x => /^es(-|$)/i.test(x.lang) && /female|mujer|woman/i.test(x.name))
        || v.find(x => /^es(-|$)/i.test(x.lang))
        || null;
    }

    /* ---------- helpers TTS ---------- */
    function playTTS(url) {
      currentAudio?.pause();                // det√©n la que hubiera
      currentAudio = new Audio(url);
      btnStop.style.display = 'flex';       // muestra bot√≥n stop

      currentAudio.addEventListener('ended', cleanupTTS);
      currentAudio.addEventListener('pause', cleanupTTS);
      currentAudio.addEventListener('error', cleanupTTS);

      currentAudio.play().catch(console.error);
    }
    function cleanupTTS() {
      if (!currentAudio) return;
      fetch(currentAudio.src, { method: 'DELETE' });   // lo borras del servidor
      currentAudio = null;
      btnStop.style.display = talking ? 'flex' : 'none';
    }

    /* ---------- cancelar GRABACI√ìN ---------- */
    function cancelRecording() {
      if (!talking) return;
      recVoice.stop();                      // onstop no enviar√° nada
      talking = false;
      btnTalk.classList.remove('talking');
      btnStop.style.display = 'none';

      log.insertAdjacentHTML(
        'beforeend',
        '<div class="feedback error">‚ùå Pregunta cancelada</div>'
      );
      chatChanged = true;
      log.scrollTop = log.scrollHeight;
    }

    /* ---------- bot√≥n STOP (voz / grabaci√≥n) ---------- */
    btnStop.onclick = () => {
      if (currentAudio) {        // se est√° oyendo la respuesta  ‚Üí parar voz
        currentAudio.pause();
      } else {                   // estamos grabando            ‚Üí cancelar
        cancelRecording();
      }
    };

    /* patr√≥n com√∫n de confirmaci√≥n */
    const confRE = /(registrad[oa]|actualizaci[o√≥]n) realizada correctamente/i;

    /* ---------- click HABLAR (voz ‚Üî assistant) ---------- */
    btnTalk.onclick = async () => {
      if (!talking) {  // ‚îÄ EMPEZAR ‚îÄ
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });

        // 1. elegir mimeType
        let options = {};
        if (MediaRecorder.isTypeSupported('audio/webm;codecs=opus')) {
          options.mimeType = 'audio/webm;codecs=opus';
        } else {
          options.mimeType = 'video/mp4';
        }

        recVoice = new MediaRecorder(stream, options);
        chunksVoice = [];
        recVoice.ondataavailable = e => chunksVoice.push(e.data);
        recVoice.start(1000);            // 2. timeslice 1s

        talking = true;
        btnTalk.classList.add('talking');
        btnStop.style.display = 'flex';
      } else {       // ‚îÄ DETENER ‚îÄ
        recVoice.stop();
        talking = false;
        btnTalk.classList.remove('talking');

        recVoice.onstop = async () => {
          // 3. determinar extensi√≥n seg√∫n mimeType
          const mime = recVoice.mimeType || 'audio/webm';
          const ext = mime.includes('mp4') ? '.mp4' : '.webm';
          const blob = new Blob(chunksVoice, { type: mime });
          const form = new FormData();
          form.append('audio', blob, 'pregunta' + ext);

          ensureLoader();  // spinner
          try {
            const r = await fetch('/api/assistant/voice', {
              method: 'POST',
              credentials: 'include',
              body: form
            });
            const j = await r.json();
            if (!j.ok) throw new Error(j.error || 'Error desconocido');

            // mostrar pregunta transcrita
            if (j.question) {
              log.insertAdjacentHTML(
                'beforeend',
                `<div class="feedback msg-user">${linkify(j.question)}</div>`
              );
              chatChanged = true;
            }
            // manejar respuesta
            await handleAssistantResponse(j);

          } catch (err) {
            removeLoader();
            log.insertAdjacentHTML(
              'beforeend',
              `<div class="feedback error">${linkify(err.message)}</div>`
            );
            if (j?.audioUrl) playTTS(j.audioUrl);
          } finally {
            if (!currentAudio) btnStop.style.display = 'none';
          }
        };
      }
    };

    $id('btnHome').onclick = () => location.href = '/inicio-consulta.html';

    const panelTxt = $id('textPanel');
    const inpMsg = $id('txtMessage');

    $id('btnKeyboard').onclick = () => {
      panelTxt.style.display = panelTxt.style.display === 'none' ? 'block' : 'none';
      if (panelTxt.style.display === 'block') { inpMsg.focus(); }
    };

    /* ---------- auto-grow del <textarea> (sin scroll interno) ---------- */
    const autoGrow = el => {
      el.style.height = 'auto';               // reset
      el.style.height = (el.scrollHeight + 2) + 'px';
    };

    /* ---------- entrada por teclado ---------- */
    inpMsg.addEventListener('keydown', async e => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        const msg = inpMsg.value.trim();
        if (!msg) return;

        inpMsg.value = '';
        autoGrow(inpMsg);

        log.insertAdjacentHTML(
          'beforeend',
          `<div class="feedback msg-user">${linkify(msg)}</div>`
        );
        chatChanged = true;
        log.scrollTop = log.scrollHeight;

        ensureLoader();                 // spinner
        let j = null;
        try {
          const r = await fetch('/api/assistant/chat', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(buildAssistantBody(msg))
          });
          j = await r.json();
          if (!j.ok) throw new Error(j.error || 'Error');

          await handleAssistantResponse(j);

        } catch (err) {
          safeRemoveLoader();
          log.insertAdjacentHTML(
            'beforeend',
            `<div class="feedback error">${linkify(err.message)}</div>`
          );
          chatChanged = true;
          log.scrollTop = log.scrollHeight;

          if (j?.audioUrl) playTTS(j.audioUrl);
        } finally {
          if (!currentAudio) btnStop.style.display = 'none';
        }

      } else {
        setTimeout(() => autoGrow(inpMsg), 0);
      }
    });


    /* ---------- GUARDAR / ACTUALIZAR EL CHAT ---------- */
    $id('btnSaveChat').onclick = async () => {

      /* 2.1 ‚Äì Nada que guardar */
      if (!chatChanged) {
        Swal.fire({
          icon: 'info',
          title: 'Sin cambios',
          text: 'No has hecho ninguna modificaci√≥n desde el √∫ltimo guardado',
          confirmButtonColor: '#276040'
        });
        return;
      }

      /* 2.2 ‚Äì Preparamos cuerpo y m√©todo */
      const body = { conversation: serializeChat() };
      if (activeChatId) body.id_chat = activeChatId;

      try {
        const r = await fetch('/api/chats/save', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body)
        });
        const j = await r.json();
        if (!j.id_chat && !j.ok) throw new Error(j.error || 'Error');

        activeChatId = activeChatId || j.id_chat;
        chatChanged = false;

        /* 2.3 ‚Äì √âXITO */
        Swal.fire({
          icon: 'success',
          title: '¬°Guardado!',
          text: 'La conversaci√≥n se ha almacenado correctamente',
          confirmButtonColor: '#276040',
          timer: 2000,
          showConfirmButton: false
        });

      } catch (err) {
        /* 2.4 ‚Äì ERROR */
        Swal.fire({
          icon: 'error',
          title: 'Ups‚Ä¶',
          text: err.message || 'Error al guardar el chat',
          confirmButtonColor: '#a12525'
        });
      }
    };

    /* =======================  SUBIDA DE ARCHIVOS  ======================= */
    const picker = $id('filePicker');
    const btnPlus = $id('btnUpload');

    btnPlus.onclick = () => picker.click();

    function addAttachmentToLog({ fileName, tmpName, isImg }) {
      const html = `
    <div class="feedback success attach" data-tmp="${tmpName}">
      üìé ${fileName} adjuntado
      <button class="btnSaveAttach" data-tmp="${tmpName}"
              title="Guardar en ficha del paciente">üìå</button>
      ${isImg ? `<br><img src="/tmp/${tmpName}" class="thumb">` : ''}
    </div>`;
      log.insertAdjacentHTML('beforeend', html);
      chatChanged = true;
      log.scrollTop = log.scrollHeight;
    }

    picker.onchange = async () => {
      if (!picker.files.length) return;

      for (const file of picker.files) {
        try {
          /* ---- 1.a ‚Äì enviamos a /tmp ---- */
          const form = new FormData();
          form.append('files', file, file.name);

          const r = await fetch('/api/files/tmp/upload', {
            method: 'POST',
            body: form,
            credentials: 'include'
          });
          const j = await r.json();
          if (!j.files?.length) throw new Error('Fall√≥ la subida');

          const tmpName = j.files[0].filename;          // ej.: tmp-123.pdf

          /* ---- 1.b ‚Äì registramos en backend ---- */
          const r2 = await fetch('/api/assistant/files/register', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ tmpName, origName: file.name }),
            credentials: 'include'
          });
          const j2 = await r2.json();
          if (!j2.ok) throw new Error(j2.error || 'Error registrando archivo');

          /* ---- 1.c ‚Äì si es imagen la a√±adimos al array vision ---- */
          if (j2.kind === 'image') {
            window.sessionImages.push(`${location.origin}/tmp/${tmpName}`);
            if (window.sessionImages.length > 5) window.sessionImages.shift(); // l√≠mite 5
          }

          /* ---- 1.d ‚Äì feedback + pin ---- */
          addAttachmentToLog({
            fileName: file.name,
            tmpName,
            isImg: /\.(png|jpe?g|webp|gif|heic)$/i.test(file.name)
          });

          chatChanged = true;
          log.scrollTop = log.scrollHeight;

        } catch (err) {
          log.insertAdjacentHTML(
            'beforeend',
            `<div class="feedback error">${err.message}</div>`
          );
          chatChanged = true;
          log.scrollTop = log.scrollHeight;
        }
      }
      picker.value = '';          // reset
    };

    /* ‚îÄ‚îÄ‚îÄ Finalizar chat si se abandona la p√°gina ‚îÄ‚îÄ‚îÄ */
    window.addEventListener('beforeunload', () => {
      /* Solo si hay un chat abierto */
      if (activeChatId !== null) {
        /* Serializamos lo que haya en pantalla */
        const payload = {
          id_chat: activeChatId,
          conversation: serializeChat(),
          finalizar: true
        };

        /* sendBeacon ‚áí dispara en segundo plano sin bloquear la salida */
        navigator.sendBeacon(
          '/api/chats/save',
          new Blob([JSON.stringify(payload)], { type: 'application/json' })
        );
      }
    });
  </script>

</body>

</html>